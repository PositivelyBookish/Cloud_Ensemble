# -*- coding: utf-8 -*-
"""Alexnet

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BHRX4xOXHQROwr8TKSWnBEKUygM34lk2
"""

import os
import warnings
import torch
from torch import nn
from torchvision import transforms, models
from PIL import Image
import matplotlib.pyplot as plt

warnings.filterwarnings("ignore")


# Constants and parameters
IMAGE_SIZE = 80
classification_types = [
    'Pepper__bell___Bacterial_spot', 'Pepper__bell___healthy',
    'Potato___Early_blight', 'Potato___Late_blight', 'Potato___healthy',
    'Tomato_Bacterial_spot', 'Tomato_Early_blight', 'Tomato_Late_blight',
    'Tomato_Leaf_Mold', 'Tomato_Septoria_leaf_spot',
    'Tomato_Spider_mites_Two_spotted_spider_mite', 'Tomato__Target_Spot',
    'Tomato__Tomato_YellowLeaf__Curl_Virus', 'Tomato__Tomato_mosaic_virus',
    'Tomato_healthy'
]

model_path = '../models/AlexNet-model-80.pth'  # Update this path to your actual model file location
if not os.path.exists(model_path):
    print("Model file not found:", model_path)
    exit(1)

model = models.alexnet(weights="DEFAULT")
model.classifier[6] = nn.Linear(4096, 15)
state_dict = torch.load(model_path, weights_only=True, map_location=torch.device('cpu'))
del state_dict['classifier.6.weight']
del state_dict['classifier.6.bias']
model.load_state_dict(state_dict, strict=False)
model.eval()

from torchvision import transforms
from PIL import Image
import torch

transform = transforms.Compose([
    transforms.Resize((80, 80)),  # Resize to match the model's input size
    transforms.ToTensor(),       # Convert to a tensor
    transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]),  # Normalize using ImageNet stats
])

# Load the image
image_path = "../test_images/Potato___Early_blight.jpg"  # Replace with your image path
image = Image.open(image_path).convert("RGB")

# Apply the transformations
input_tensor = transform(image).unsqueeze(0)  # Add batch dimension


# Ensure the model is in evaluation mode
model.eval()

# Perform the forward pass to get predictions
with torch.no_grad():  # No gradients needed during inference
    output = model(input_tensor)

# Get the predicted class and confidence score
_, predicted_class = torch.max(output, 1)  # Get the index of the highest score
confidence = torch.softmax(output, dim=1)[0, predicted_class].item()  # Confidence score

# Define the class names
classification_types = [
    'Pepper__bell___Bacterial_spot', 'Pepper__bell___healthy',
    'Potato___Early_blight', 'Potato___Late_blight', 'Potato___healthy',
    'Tomato_Bacterial_spot', 'Tomato_Early_blight', 'Tomato_Late_blight',
    'Tomato_Leaf_Mold', 'Tomato_Septoria_leaf_spot',
    'Tomato_Spider_mites_Two_spotted_spider_mite', 'Tomato__Target_Spot',
    'Tomato__Tomato_YellowLeaf__Curl_Virus', 'Tomato__Tomato_mosaic_virus',
    'Tomato_healthy'
]

# Get the predicted class name
predicted_label = classification_types[predicted_class.item()]

# Print the result
print(f"Predicted Class: {predicted_label}")
print(f"Confidence: {confidence:.2%}")